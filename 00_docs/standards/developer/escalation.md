# Эскалация от Developer

Когда и как эскалировать проблемы к Analyst или Architect.

## Когда эскалировать

### К Analyst
- Технический план неполон или противоречив
- Обнаружены блокирующие технические проблемы
- Требуются уточнения по реализации
- Найдены несоответствия в `analysis.md`
- Невозможно реализовать согласно плану

### К Architect
- Критические архитектурные проблемы в процессе разработки
- Невозможность следовать ADR из-за новых обстоятельств
- Обнаружено фундаментальное противоречие в архитектуре

## Общее правило

**Сначала эскалируй к Analyst.** Architect нужен только для архитектурных изменений.

## Эскалация к Analyst

### Шаг 1: Создай файл с вопросами

Создай `01_tasks/NNN/_questions_analyst.md`:

```markdown
# Вопросы для Analyst

**От:** Developer
**Дата:** YYYY-MM-DD

## Вопрос 1: [Короткое название]

**Проблема:**
[В чем конкретно проблема с техническим планом]

**Контекст:**
[Что ты пытался реализовать]

**Что блокирует:**
[Почему невозможно продолжать без ответа]

**Твое предложение (если есть):**
[Как бы ты решил, если бы мог]

---

## Вопрос 2: [Если есть]
...
```

### Шаг 2: Сформируй промпт для Analyst

```
Ты — агент Analyst (см. .agents/analyst.md).

Прочитай:
- .agents/analyst.md
- 01_tasks/NNN/_questions_analyst.md
- 01_tasks/NNN/analysis_01.md
- 01_tasks/NNN/task_brief_01.md

Задача: Ответь на вопросы Developer. Обнови технический план при необходимости.

После ответа сформируй промпт для возврата Developer к работе.
```

### Шаг 3: Положи промпт в чат

Используй markdown блок (```) для удобного копирования.

### Шаг 4: Останови работу

**НЕ продолжай реализацию** пока Analyst не обновит план.

## Эскалация к Architect

Используй только для критических архитектурных проблем.

### Шаг 1: Создай файл с вопросами

Создай `01_tasks/NNN/_questions_architect.md`:

```markdown
# Вопросы для Architect

**От:** Developer
**Дата:** YYYY-MM-DD

## Вопрос: [Название архитектурной проблемы]

**Проблема:**
[В чем архитектурное противоречие]

**Контекст:**
[Что обнаружил во время реализации]

**Текущий ADR:**
[Какой ADR нарушается или противоречит]

**Почему невозможно следовать ADR:**
[Новые обстоятельства]

**Варианты (если есть):**

### Вариант A: [Название]
- **Подход:** ...
- **Плюсы:** ...
- **Минусы:** ...

### Вариант B: [Название]
- **Подход:** ...
- **Плюсы:** ...
- **Минусы:** ...

**Блокирует:**
[Почему невозможно продолжать]
```

### Шаг 2: Сформируй промпт для Architect

```
Ты — агент Architect (см. .agents/architect.md).

Прочитай:
- .agents/architect.md
- 01_tasks/NNN/_questions_architect.md
- 00_docs/architecture/overview.md
- 00_docs/architecture/decision_NNN_relevant.md

Задача: Ответь на архитектурные вопросы от Developer. Обнови релевантные ADR.

После ответа сформируй промпт для возврата Developer к работе.
```

### Шаг 3: Останови работу

**НЕ продолжай реализацию** пока Architect не примет решение.

## Примеры хороших эскалаций

### Пример 1: К Analyst - Неполнота плана

```markdown
## Вопрос: Обработка ошибок валидации

**Проблема:**
В analysis_01.md описан EmailValidator, но не указано:
- Какой формат ошибок возвращать?
- Где логировать failed валидации?
- Retry policy для DNS lookup?

**Контекст:**
Реализую EmailValidator из раздела 3.2.1

**Что блокирует:**
Невозможно реализовать error handling без этих деталей.

**Твое предложение:**
Предлагаю использовать ValidationError с кодом и сообщением,
аналогично существующему UserValidator.
```

### Пример 2: К Analyst - Противоречие

```markdown
## Вопрос: Противоречие в хранении данных

**Проблема:**
- Раздел 3.3 говорит хранить в PostgreSQL
- Раздел 4.2 упоминает Redis cache
- Но не указано что именно в Redis

**Контекст:**
Реализую data access layer

**Что блокирует:**
Непонятна data flow между PostgreSQL и Redis

**Твое предложение:**
Нужны явные правила: что в PostgreSQL, что в Redis, TTL для кеша.
```

### Пример 3: К Architect - Архитектурная проблема

```markdown
## Вопрос: Rate limiting на gateway уровне

**Проблема:**
Согласно ADR-007 rate limiting должен быть в каждом сервисе.
Но при реализации обнаружил что это создает inconsistency:
клиент получает разные лимиты от разных сервисов.

**Текущий ADR:**
00_docs/architecture/decision_007_rate_limiting.md

**Почему невозможно следовать:**
При microservices архитектуре клиент может за одну операцию
обратиться к 3+ сервисам, каждый со своим лимитом.

**Варианты:**

### Вариант A: Централизованный rate limiting на gateway
- Плюсы: Единая точка контроля
- Минусы: Изменение ADR-007

### Вариант B: Shared rate limiting store (Redis)
- Плюсы: Сохраняет ADR-007
- Минусы: Dependency на Redis

**Блокирует:**
Невозможно реализовать корректный rate limiting без решения.
```

## После получения ответа

### От Analyst
- Analyst обновит `analysis_NN.md`
- Получишь промпт для возврата к работе
- Продолжишь реализацию с учетом обновленного плана

### От Architect
- Architect создаст/обновит ADR
- Получишь промпт для возврата к работе
- Продолжишь реализацию с учетом архитектурного решения
